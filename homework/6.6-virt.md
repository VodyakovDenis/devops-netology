# Домашнее задание к занятию 6. «Troubleshooting»## Задача 1Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD-операция в MongoDB и её нужно прервать. Вы как инженер поддержки решили произвести эту операцию:- напишите список операций, которые вы будете производить для остановки запроса пользователя;- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.### Решениеdb.currentOp() - для того, чтобы найти зависшую операцию. Для 3ех минут: db.currentOp({"secs_running":{$gte: 180}})db.killOp() - для того, чтобы прервать выполнение команды. Для примера пусть будет: db.killOp("shardA:100813");maxTimeMS() - для того, чтобы ограничить время на выполнение CRUD-операций. Для примера db.collection.find({description: /August [0-9]+, 1969/}).maxTimeMS(180) - ограничили запрос тремя минутами.   https://www.mongodb.com/docs/manual/reference/method/cursor.maxTimeMS/   https://www.mongodb.com/docs/manual/reference/method/db.killOp/## Задача 2Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причём отношение количества записанных key-value-значений к количеству истёкших значений есть величина постоянная иувеличивается пропорционально количеству реплик сервиса. При масштабировании сервиса до N реплик вы увидели, что:- сначала происходит рост отношения записанных значений к истекшим,- Redis блокирует операции записи.Как вы думаете, в чём может быть проблема?### РешениеС Redis только начинаю знакомиться, но могу предположить:Раздел: Latency generated by expires (в переводе на Русский).   	В основном это означает, что если в базе данных есть много-много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% текущей совокупности ключей с установленным сроком действия, Redis может заблокировать, чтобы получить процент ключей, срок действия которых уже истек. ниже 25%.   Получается:   Рост записанных к истекшим по логике говорит о том, что скорее всего растет размер хранилища, и возможно память заканчивается. Блокировка на запись, может говорить о том, что выделенная память закончилась.   https://redis.io/commands/ttl/   https://redis.io/docs/management/optimization/latency/   Еще есть интересный момент: TTL - Возвращает оставшееся время жизни ключа, для которого истекло время ожидания. Судя по разделу Latency induced by network and communication, виной всему может быть так-же сеть. ## Задача 3Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базыпользователи начали жаловаться на ошибки вида:```pythonInterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '```Как вы думаете, почему это начало происходить и как локализовать проблему?Какие пути решения этой проблемы вы можете предложить?### Решение1. Возможно проблемы с сетью и нужно скорректировать connect_timeout   2. Большой запрос net_read_timeout (30 секунд по умолчанию). Увеличить данный параметр   3. Как вариант проблема может быть в размере сообщения max_allowed_packet4. Смотрим в сторону оптимизации запроса## Задача 4Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объёмом данных лучше, чем MySQL.После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:`postmaster invoked oom-killer`Как вы думаете, что происходит?Как бы вы решили эту проблему?### РешениеOOM Killer - процесс, который завершает приложение при нехватки памяти.   Скорее всего на сервере "Слоника" закончилась оперативная память.   Как вариант задать ограничение памяти выделяемой PostgreSQL   Если виной послужил запрос, сбросить его и попробовать поделить на пачки - ограничив размер.   Не использовать на одном сервере несколько требовательных к памяти приложений   Если нельзя "ужаться" ограничением памяти, возможно нужно подумать о ее расширении   